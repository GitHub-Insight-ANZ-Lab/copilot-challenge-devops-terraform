## Challenge 1: Migrate Jenkins Pipeline to GitHub Actions

### Objective

The goal of this exercise is to use GitHub Copilot to help you write a GitHub Actions workflow that mirrors a Jenkins pipeline. You will be provided with a sample Jenkinsfile that defines a simple pipeline for building and verifying Terraform code. Your task is to use GitHub Copilot to assist you in writing the equivalent GitHub Actions workflow.

The following is a sample Jenkinsfile for a simple pipeline that builds and verifies terraform code
```groovy
pipeline {
    agent any

    environment {
        // Define Terraform version to use (if Terraform is installed via tfenv)
        TF_VERSION = '1.5.0'
        // Directory where your Terraform files are located
        TERRAFORM_DIR = 'terraform'
        // Azure environment variables (use Jenkins credentials for secure authentication)
        ARM_CLIENT_ID = credentials('azure-client-id')
        ARM_CLIENT_SECRET = credentials('azure-client-secret')
        ARM_SUBSCRIPTION_ID = credentials('azure-subscription-id')
        ARM_TENANT_ID = credentials('azure-tenant-id')
    }

    stages {
        stage('Initialize') {
            steps {
                echo "Initializing Terraform..."
                dir(TERRAFORM_DIR) {
                    sh 'terraform init'
                }
            }
        }

        stage('Validate Terraform') {
            steps {
                echo "Validating Terraform files..."
                dir(TERRAFORM_DIR) {
                    sh 'terraform validate'
                }
            }
        }

        stage('Run Terraform Plan') {
            steps {
                echo "Running Terraform Plan..."
                dir(TERRAFORM_DIR) {
                    sh 'terraform plan --out tfplan.binary'
                }
            }
        }

        stage('Run Trivy Checks') {
            steps {
                echo "Running Trivy configuration checks..."
                dir(TERRAFORM_DIR) {
                    // Instead of checking the plan file, scan the actual Terraform config files (.tf)
                    sh 'trivy config --severity HIGH,CRITICAL .'
                }
            }
        }

        stage('Terraform Apply') {
            steps {
                script {
                    input message: 'Do you want to proceed with Terraform apply?'
                }
                echo "Applying Terraform changes to Azure..."
                dir(TERRAFORM_DIR) {
                    // Apply the Terraform plan using the correct plan filename (tfplan.binary)
                    sh 'terraform apply -auto-approve tfplan.binary'
                }
            }
        }

        stage('Archive Terraform Plan') {
            steps {
                echo "Archiving the Terraform Plan output..."
                dir(TERRAFORM_DIR) {
                    // Ensure the correct plan file (tfplan.binary) is archived
                    archiveArtifacts artifacts: 'tfplan.binary', allowEmptyArchive: true
                }
            }
        }
    }

    post {
        always {
            echo "Cleaning up..."
            dir(TERRAFORM_DIR) {
                // Clean up only the Terraform-generated plan and temp files, not the entire directory
                sh 'rm -f tfplan.binary tfplan.json'
            }
        }
        success {
            echo 'Pipeline completed successfully.'
        }
        failure {
            echo 'Pipeline failed. Please check the logs.'
        }
    }
}
```

### Task

Your task is to use GitHub Copilot to help you write a GitHub Actions workflow that mirrors the Jenkins pipeline defined above. The GitHub Actions workflow should be triggered on every pull request and push to the main branch. It should include the following jobs:

**Prep:** Set up the GitHub Actions workflow file

- Create a new file in your repository named `.github/workflows/terraform-pipeline.yml`
- Begin typing name: and use GitHub Copilot to generate the boilerplate for the workflow name and triggers.

**Tip:** Start typing on: and let Copilot suggest pull request and push triggers.

**Step 1:** Define Terraform Initialization Job

- Create a job called initialize that runs on ubuntu-latest using Copilot. Start typing “jobs:” and Copilot will help you define the job structure.
- Add the Terraform initialization step `terraform init` with Copilot’s assistance.

**Tip:** Copilot will suggest the steps: and the working directory where your Terraform files are located.

**Step 2:** Validate Terraform Files

- Define the next job or step for validating Terraform. Type `terraform validate` and let Copilot autocomplete the command for validating the Terraform files.

**Tip:** Copilot will offer syntax for the terraform validate command, ensuring it runs within the correct directory.

**Step 3:** Run Terraform Plan

- Create a new job to run the Terraform plan. Begin typing `terraform plan` and Copilot will suggest the correct syntax, including specifying the output plan file (tfplan.binary).

**Tip:** Ensure Copilot suggests a valid directory path and flags for outputting the plan to a file.

**Step 4:** Run Trivy Checks

- Add a step for running Trivy checks. Copilot can help install Trivy and suggest the correct command `trivy config --severity HIGH,CRITICAL .`.

**Tip:** Start typing `install trivy` and Copilot will offer a command for installing Trivy in your environment.

**Step 5:** Apply Terraform Changes

- Create a job for applying Terraform changes. Begin typing `terraform apply` and Copilot will complete the step, including the necessary flags like -auto-approve and the input file (tfplan.binary).

**Tip:** Copilot can also help you add a step to prompt user confirmation before applying the changes.

**Step 6:** Archive Terraform Plan Output

- Add a step for archiving the Terraform plan. Start typing archiveArtifacts: and let Copilot suggest the correct path and file (e.g., tfplan.binary).

**Tip:** Copilot will help you complete the YAML for archiving the output file, ensuring the correct syntax.

You can use the provided Jenkinsfile as a reference to help you write the GitHub Actions workflow. GitHub Copilot will assist you in generating the necessary YAML configuration and commands for the workflow.

### Success Criteria

- The GitHub Actions workflow should run successfully and output a Terraform plan.
- The workflow should be structured and run without errors.
- Use of GitHub Copilot to streamline the development process.

## Challenge 2: Build, Test and Package .NET application using GitHub Actions

### Objective

The goal of this exercise is to refactor the previously created GitHub Actions workflow to include additional steps for building, testing and dockerizing a sample .NET Core application. You will use GitHub Copilot to help you write the necessary Dockerfile and YAML configuration and commands for the workflow.

### Task:

You have a sample .NET Core application `./sample_dotnet_app` that you want to build, test and dockerize using GitHub Actions. Your task is to refactor the existing GitHub Actions workflow to include the following steps:

1. Create a Dockerfile to package the application.
2. Build the .NET Core application using `dotnet build`.
3. Run unit tests using `dotnet test`.
4. Publish the application using `dotnet publish`.
5. Build a Docker image using the Dockerfile.

You can use the provided sample .NET Core application as a reference to help you write the GitHub Actions workflow. GitHub Copilot will assist you in generating the necessary Dockerfile and YAML configuration and commands for the workflow.

### Success Criteria

- The GitHub Actions workflow should run successfully.
- The workflow should be structured and run without errors.
- Use of GitHub Copilot to streamline the development process.


### What's next?

Once you've completed the challenges, you may like to review the [additional resources](<./5. additional resources.md>) to learn more about GitHub Copilot and how it can help you in your day to day work.